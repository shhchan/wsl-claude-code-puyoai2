# 個人開発 AI PoC 用メモ

## はじめに
Claude Code を個人開発 AI PoC として利用するが，どのような手順でどのようなことを行なったのかをメモすることで，のちに作成する報告用レポートで活用できるようにする．

## AI PoC でレポートする内容
Google Form で事前に伝えた取組み内容は以下：

### 個人環境において，今回の取り組みでどのように利用する予定か

以下2点を現状は想定している：
1. ぷよぷよ AI 開発に必要なタスクをイチから行なわせてみる
2. 探索アルゴリズムや強化学習モデルの構築など，高度な実装を行なわせてみる

**1.** について，この開発自体は私が個人的に行なってきたものだが，2025/06/14 から開発環境を刷新していた．
具体的には，すべての処理を C++ で実装していたところから，描画部分を python，エミュレータ部分を C++ で実装するように Github Copilot（Free プラン）を用いて修正していた．
同様のタスクを Claude Code に実施させることで，正確性や開発速度の変化に着目する．

**2.** について，探索アルゴリズムや強化学習もでるのこうちくも　個人的に行なってきたものだが，2025/06/14 から刷新した新しい pj の方ではまだランダムモデルしか構築していない状態になっている．
具体的なアルゴリズムのアイデアがないような状態でこれらのモデル構築を Claude Code に実施させることで，具体度が低いが高度なタスクに対してどのようにアプローチでき，どの程度の成果を出すことができるかに着目する．

### FW の業務でどのように活用できる想定か

**1.** の内容をもとに，ある程度の知識あるいは情報が存在する条件で，pj 立ち上げ時の最初の環境構築や事前準備を高速で実施し，本来注力すべきタスクにより力をいれることができるようになることを想定している．

**2.** の内容をもとに，具体的なアイデアが出せていないが高度なタスクに対して，より多くの人が草案的にその機能を実現するようになり，結果的に難易度の高いタスクに対して品質を確保しつつ時間短縮できるようになることを想定している．

## セットアップ

https://docs.anthropic.com/ja/docs/claude-code/overview に従って，Claude Code をインストールする．

```shell
npm install -g @anthropic-ai/claude-code
```

Claude Code を試しに使ってみるために，作業ディレクトリを作成する．

```shell
mkdir sample-claude-code-pj
```

↑ で作成した作業ディレクトリ `sample-claude-code-pj/` へ移動し，そこで `claude` を実行する．

```shell
cd sample-claude-code-pj/
claude
```

## WSL 上で使えるようにしてみる

WSL で Ubuntu を開く（この辺りの設定は個人で使っていたもの）：

```shell
wsl -d Ubuntu
```

以下のコマンドで `nodejs` をインストールする：

```shell
curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
```

```shell
sudo apt-get install -y nodejs
```

`ndoejs` のがインストールされたか確認する：

```shell
$ node -v
v22.17.1
```

Claude Code をインストールしようとしたところ，以下のようなエラーが出た：

```shell
$ npm install -g @anthropic-ai/claude-code
npm error code EACCES
npm error syscall mkdir
npm error path /usr/lib/node_modules/@anthropic-ai
npm error errno -13
npm error Error: EACCES: permission denied, mkdir '/usr/lib/node_modules/@anthropic-ai'
npm error     at async mkdir (node:internal/fs/promises:858:10)
npm error     at async /usr/lib/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js:624:20
npm error     at async Promise.allSettled (index 0)
npm error     at async [reifyPackages] (/usr/lib/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js:325:11)
npm error     at async Arborist.reify (/usr/lib/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js:142:5)
npm error     at async Install.exec (/usr/lib/node_modules/npm/lib/commands/install.js:150:5)
npm error     at async Npm.exec (/usr/lib/node_modules/npm/lib/npm.js:207:9)
npm error     at async module.:wq
uexports (/usr/lib/node_modules/npm/lib/cli/entry.js:74:5) {
npm error   errno: -13,
npm error   code: 'EACCES',
npm error   syscall: 'mkdir',
npm error   path: '/usr/lib/node_modules/@anthropic-ai'
npm error }
npm error
npm error The operation was rejected by your operating system.
npm error It is likely you do not have the permissions to access this file as the current user
npm error
npm error If you believe this might be a permissions issue, please double-check the
npm error permissions of the file and its containing directories, or try running
npm error the command again as root/Administrator.
npm error A complete log of this run can be found in: /home/sion2000114/.npm/_logs/2025-07-26T04_08_45_790Z-debug-0.log
```

以下のコマンドを順に実行することで，Claude Code のインストールを行なった：

```shell
npm list -g --depth=0 > ~/npm-global-packages.txt
mkdir -p ~/.npm-global
npm config set prefix ~/.npm-global
echo 'export PATH=~/.npm-global/bin:$PATH' >> ~/.bashrc
source ~/.bashrc
npm install -g @anthropic-ai/claude-code
```

## Claude Code を使ってみる（Vibe）

そもそもどのように Claude Code を使うのかが確立していない状態なので，上で作った `sample-claude-code-pj` 内で何か作ってみる．

次のように指示を出してみた：

```
はじめて Claude Code を使うので，Claude Code の使い方になれるための簡単なアプリ開発を行なってみたいです．
```

これに対して， Claude Code は自動的に TODO アプリを作り始めた．

また，レポート用に Claude Code とのやり取りを記録するよう，次のような指示を出した：

```
このプロジェクトの内容とは独立しているのですが，Claude Code を使ってみてどうだったかをレポーティングする必要があるので，Claude Code とどのようなやり取りを通じてどのようなタスクを行なったかを随時まとめてほしいです．
```

```
レポートファイルを随時更新するよう，`claude.md` に記述しておいてください．
```

このようにすることで，`claude-code-report.md` と `claude.md` を作成してくれた．

本当に `claude.md` に記載したことで毎回作業ログを残してくれるようになったのか確認するために，追加機能開発をお願いしてみた．

```
タスクを追加しても，ページをリロードすると追加したタスクがなくなってしまっているので，なくならないようにしてほしいです．
```

この指示によって，実際にページをリロードしても追加したタスクが残るようになり，`claude-code-report.md` にも追加機能開発の内容を追記してくれた．

## Claude Code を使ってみる（Spec）

Spec というのは，仕様をあらかじめきちんと決めておいてから開発を進めてもらう方式のことを指している．
Kiro という AWS が出した新しい AI IDE の用語を引っ張ってきている．

ということで，別 pj として新たに `wsl-sample-claude-code-pj2/` を作成し，そこで `claude` を実行する．

```shell
cd ~/workspaces
mkdir wsl-sample-claude-code-pj2
cd wsl-sample-claude-code-pj2
claude
```

トランプのババ抜きをオンライン対戦できるようにしてみる．

```
トランプのババ抜きをオンラインでプレイできる web サービスの開発を行ないたいです．これから要件を決めていきたいので，内容を整理して `claude.md` を作成したいです．
```

```
あまり複雑にしなくてよいです．参加者は2人だけとします．参加者は最初にユーザ名を設定するようにします．その後，参加者2人がそろったらゲーム開始ボタンを押せるようにし，ゲームが終了したら勝敗をそれぞれのユーザに表示します．その後，ゲームを再開するかどうか確認するようにしたいです．
```

```
 では，要件定義に沿って実装を始めてください．実装内容に対してテストも必ず記載するようにしてください．
```

このようにすることで，実行可能な web サービスを構築することはできた．

実際にプレイしてみると分かるが，明らかにゲームが完了しない状態になっている．
![alt text](image.png)

これを修正してもらう．

```
実際にプレイしてみると，明らかにババ抜きが完了しない状態になっていました．たとえば，user1 の手札が ジョーカー・ダイヤ9・ハートA・ハートQ で，user2 の手札がダイヤ5・ダイヤ3となっていました．
```

まだ修正できていなかったので，再度修正を依頼する．

```
まだバグが残っているようです．user2 の最初の手札の中にクローバーQ・ハートQ が残っている状態になっていました．手札から重複する数字のペアを取り除く処理をもう一度確認してください．
```

まだ解決しない．中々 Claude Code だけでエラーを解決するのは難しいのかもしれない．

... と思ったら，キャッシュが残っていて正常に動作していないだけだった．

エラー内容を伝えることで，エラーログを確認して実際に修正してくれることが分かった．

## ぷよぷよ AI 開発基盤の作成を Claude Code で実施してみる

新たに `wsl-claude-code-puyoai/` を作成して，そこで開発を行なう．

Claude とやり取りを通じて，ぷよぷよ AI 開発基盤の作成のための `claude.md` の内容を作成した．
https://claude.ai/chat/b1a1238d-32e3-45eb-b3dd-e6f906ff6aaa

その内容をもとに，Claude Code に次のように指示を出した．

```
`claude.md` を読んで，まずは pj の目標を理解してください．そして，具体的なクラス設計などをして，開発ステップを別ドキュメントにまとめてください．
```

これによって，`design_document.md` を作成してもらった．

この内容をもとに Claude Code に基本的なぷよぷよのエミュレータ部分の作成をお願いしたのだが，結論としてはうまくコンパイルして実行するところまで至らなかった．
エミュレータを実装してほしいという形で依頼したので，一度に多くのことを依頼しすぎてしまったのかもしれない．


## ぷよぷよ AI 開発基盤の作成を Claude Code で実施してみる（2回目）

この内容を AI PoC で報告するレポート作成のための1つ目の検証「ぷよぷよ AI 開発に必要なタスクをイチから行なわせてみる」とする．

2回目（`wsl-claude-code-puyoai2/`）はよりタスクを細かく分割して依頼するようにしてみる．
そのために，作成した要件定義書からタスク分割（チケット化）を行なってもらうことにする．

```
`claude.md` に記載された要件定義をもとに，タスクをチケット化してください．
`/docs` 配下に配置してください．
ファイルは `.md` で，ファイル名に連番を振ってください．
各ファイルで TODO 管理もします．
- [] で終わったら - [x] を入れるように `claude.md` に追記しておいてください．
```

順にタスクをチケット化してもらう中で，各タスクがシンプルになるように必要最低限の内容のみを取捨選択して，それを Claude Code へ伝えるというサイクルを繰り返してもらった．
チケットを確認して修正してというサイクルを5分程度繰り返した．
- https://github.com/shhchan/wsl-claude-code-puyoai2/commit/28b25fb47545e6086cc4f0b77949187c14e84b51

チケット分割ができたので，1つずつ実施してもらう．

```
では，まずはチケット 001 を実施してください．
タスクを細かく分割して実装していきたいので，チケット 001 だけを実施対象とします．
```

テスト実施まで完了した後に，テスト用に作成したファイルを削除しようとしていたので，記録を残すよう指示出しを追加した．

```
実施したテスト内容と結果については記録を残しておきたいです．
テスト用に作成したファイル自体は削除しても問題ありません．
```

```
記載の方向性は問題ないですが，テスト用に作成したファイルはやっぱり削除しないようにしてください．
代わりに，以下のようにしてください：
- テスト用のディレクトリを作成してそこで管理するようにする
- テスト結果を記述したドキュメントには，具体的なテストの実施方法についても記載するようにする

これを考慮して，再度テストを実行してテスト結果をまとめてください．

また，ここまでに述べてきたテストの扱いについて，`claude.md` 荷物息しておいてください．
```

これによって，15分程度で環境構築から binding のテストまで実施できた．
- https://github.com/shhchan/wsl-claude-code-puyoai2/commit/551fb3815b7bd031057b20b61d1ae046f061a448


続いて，チケット 002 を実施してもらう．

```
続いて，チケット 002 を実施してください．
```

ビット演算でフィールド処理を行なってほしいのに，チケット 002 の方には記述できていなかったので，Claude Code とのインタラクティブなやり取りを通じて指示を出した．

```
フィールドの計算を高速化するために，bit 演算を想定した設計にしてほしいです．
```

その後，`Field` クラスの実装に入り，ぷよを重力に従って落下させる処理について，せっかくビット演算でフィールドを処理できるようにしたのにそれが活用されていなかった．
ただ，ここでビット演算を用いた実装をやらせようとすると最後まで動かないものが出来上がる可能性があるので，一旦我慢して次のように指示を出した．

```
`Field` クラスでビット演算ができるようになったので，本来はもっと効率的な `apply_gravity()` の実装方法があったと思います．
しかし，ここでビット演算を巧みに使った実装をすると，最後まで動かないプログラムが出来上がる可能性があります．
なので，すべてのチケットの実装が完了した後にリファクタリングするようにしておきたいです．
`apply_gravity()` のロジックを改善するという内容のチケットを作成してから，次の作業へ進んでください．
```

ぷよ操作を実装するフェーズまで来た．
回転処理で操作中のぷよのキック処理が入るのだが，それが実装されていないので，指摘する．

```
回転に対する重要な重要である「まわし」「クイックターン」の説明が抜けていたので，`claude.md` に追記しました．
その内容を考慮して，回転ロジックの修正をお願いします．
```

実装が完了し，テストを作成・実行するところまで来た．
テストの内容は一部手動で書き換えて実施したところ，色々エラーが発生した．
特に，`claude.md` に記載したはずの床キックが実装されていなさそうだったので，それを実装するよう指示した．

```
床キックも実装され散る必要があります．
テストを修正するのではなく，実装の方を修正してください．
```

```
`claude.md` にぷよの回転に関する情報を追記しました．
これをもとにキックの実装を修正してください．

- **回転**: 軸ぷよを中心とした4つの回転状態
  - **キック**: ぷよを回転させようとしたとき，子ぷよが壁・床・他のぷよに接触している場合，軸ぷよの位置を1マスずらす
    - 右に壁がある場合: 左へ1マス移動
    - 左に壁がある場合: 右へ1マス移動
    - 下に壁（＝床）がある場合: 上へ1マス移動
    - 左右に壁がある場合: クイックターンへ
  - **クイックターン**: 操作しているぷよの両側が壁になっているとき，回転操作を2回行なうと上下のぷよが反転（180度回転）する
```

さらに細かく言及：

```
より詳細に `claude.md` に追記したので，これをもとにキック処理を修正してください．

- **回転**: 軸ぷよを中心とした4つの回転状態
  - **キック**: ぷよを回転させようとしたとき，子ぷよが壁・床・他のぷよに接触している場合（回転時に子ぷよが壁・床・他のぷよにめり込む場合），軸ぷよの位置を1マスずらす
    - 左に壁・ぷよがある場合:
      - 上から反時計回り: x 方向に +1
      - 下から時計回り: x 方向に +1
    - 右に壁・ぷよがある場合:
      - 上から時計回り: x 方向に -1
      - 下から反時計回り: x 方向に -1
    - 左右両方に壁・ぷよがある場合:
      - クイックターンへ
    - 下に壁（＝床）・ぷよがある場合:
      - 右から時計回り: y 方向に +1
      - 左から反時計回り: y 方向に +1
  - **クイックターン**: 操作しているぷよの両側が壁になっているとき，回転操作を2回行なうと上下のぷよが反転（180度回転）する
    - 最初の回転操作ではぷよは回転せず，2つ目の回転操作ではじめて組ぷよの上下が反転する
```

これによってようやくテストがすべて成功するようになった．
細かな仕様を調べたり伝え方を考えるのに時間を取られてしまったので，ここで 2h ほど消費してしまった．

次に進む．

```
続いて，チケット 003 を実施してください．
```

基本的に内容にそこまで問題は見られなかったので，そのままテストも書かせて，失敗したテストの内容をもとに実装を修正して，テストが最後まで通るところまでやってくれた．
およそ 30min. 程度のことだった．

次に進む．

```
続いて，チケット 004 を実施してください．
```

おじゃまぷよについての記述が漏れていたので， `claude.md` に追記して次のように Claude Code に指示を出した．

```
`claude.md` に記述しましたが，おじゃまぷよについての考慮漏れがあります．
以下のことも考慮して，タスクを続けてください．

### おじゃまぷよシステム
- **送信レート**: 70点につき1個のおじゃまぷよ
  - 連鎖スコアを70で割った余りについては，次の連鎖に繰り越される
    - 例：連鎖スコアが150点だった場合，150 = 70 * 2 + 10 となるため，2個のおじゃまぷよとあまりの10点が次のおじゃまぷよの個数の計算に用いられる．次の連鎖スコアが80点だった場合，10 + 80 = 90 = 70 * 1 + 20 となるため，1個のお邪魔ぷよとあまりの20点が次のおじゃまぷよの個数の計算に用いられる．
- **相殺システム**: 予告おじゃまぷよを自分の連鎖得点で相殺可能
  - おじゃまぷよが降るタイミングで相殺できなかった分のおじゃまぷよは，N 段 + r 個の形で上から降ってくる．
    - 例えば，20個のおじゃまぷよが降ってくる場合，フィールドの幅は6マスなので 20 = 6 * 3 + 2 より，3段＋2個のおじゃまぷよがフィールド上部から降ってくる．2個の部分については，ランダムな2列が選択される．
- **おじゃまぷよ**: 色を持たず連鎖に参加しないが、隣接色ぷよ消去時に一緒に消える
```

この記述によって，テストの記述・テストの実施・レポーティングまでやってくれた．
およそ 30min. 程度のことだった．

次に進む．

```
続いて，チケット 005 を実施してください．
```

実装内容自体に問題はなさそうで，単体テストの内容を一部書き換えた程度．
およそ 15min.

次に進む．

```
続いて，チケット 006 を実施してください．
```

これまでのチケットで C++ ファイルを複数生成してから，pybind11 を使った実装を試みようとした段階で，Claude Code が混乱し始めた．
チケット 001 で作成したテストを修正し始めたりしたので，一旦 Claude Code を閉じて，履歴を引き継がない状態で再度チケット 006 の作業を依頼することにする．

```
まずは `claude.md` を読んでプロジェクトの概要を理解してください．
現在，Claude Code を用いてチケット 005 まで進んでいます．
チケット 006 を対象として，作業を開始してください．
```

テストまで記述したが実際にテストを実行するところまで至らなかったので，追加で指示出しをする．

```
`claude.md` に記述した通り，テストを実際に実施して，テストが完了したら実施した内容についてチケットにまとめて記述する必要があります．
```

また過去のテストを削除しようとしていたので，過去のテストを削除しないように指示出しをする．

```
過去のテストは削除しないようにしてください．
```

```
venv が既にあるので，それも利用するようにしてください．
過去のテストを削除しないこと・実行時には venv を利用することを `claude.md` に追記したうえで，テスト実行へ進んでください．
```

お盆期間中に PC を触れなかったので，久しぶりに Claude Code を起動する．
これで履歴を指定して Claude Code を起動する

```
claude -r
```

作業を再開する

```
続いて，チケット 007 を実施してください．
```

C++ のコアの部分の実装をある程度丁寧にやったことで，Python による描画は比較的簡単に進んだように感じた．
およそ 10min.

ところが，実際にテストの一部（`ui_interactive_demo.py`）を実行して動作確認をしてみたところ，エミュレータ方式（時間経過による自由落下なし）が満たされていない状態になっていた．
落下（ハードドロップ）は明示的にキー入力をされたときにだけ行なわれるようにしたいので，追加指示を出す．

```
チケット 007 の実施内容に不備を発見しました．
本来はエミュレータ方式なので時間経過による自由落下は行なわないということを `claude.md` に記載していました．
現在の実装では時間経過によって落下（ハードドロップ）が行なわれている状態なので，修正が必要です．

- 落下（ハードドロップ）させる場合は，明示的に落下させるボタンを押すことで落下させる（時間経過では落下させない）
- （optional）個人的に現在のキー設定では操作しづらいので，次のように変更してください：
  - A/D 左右移動
  - ↓/→ 回転（反時計回り/時計回り）
  - W ドロップ

まずは，チケット 007 のバグフィックス用のチケットを `docs/` に作成してください．
```

チケット 007a を作成してもらってから，バグフィックスしてもらう．

```
チケット 007a をまずは実施してください．
```

チケット 007a の実施によって，明示的なハードドロップのみによってぷよを落下させることができるようになった．
他にも人間が初めてプレイすることによって確認される問題はありそうなので，もう少し動作確認してみる．

`ui_interactive_demo.py` で動作確認を行なっていたところ，いくつか修正したい箇所がピックアップできた．

 - エミュレータなので，13段目・14段目も表示していてほしい
 - 操作中のぷよの回転によって壁キックが発生する状況で回転が行なえなかった（実際は壁キックが発生する場合は軸ぷよがズレたのちに回転する挙動が求められている）

これらを追加でバグ報告して，対応してもらう．

```
実際にプレイしたことで，次の不具合を発見しました：

 - エミュレータなので，13段目・14段目も表示していてほしい
 - 操作中のぷよの回転によって壁キックが発生する状況で回転が行なえなかった（実際は壁キックが発生する場合は軸ぷよがズレたのちに回転する挙動が求められている）

まずは，チケット 007 のバグフィックス用のチケットを `docs/` に作成してください．
その後，作成したバグフィックスチケットの内容を実施してください．
```

作業を進めてもらったところ，python 側で壁キックの実装をしようとしていたので，それは阻止したい．
C++ でそのあたりは実施済みなはずなので，それを活用するよう追加指示を出す．

```
壁キックの処理は C++ 側で既に実装済みなはずなので，それを活用するようにしてください．
```

まだだめそう．
`puyo_controller.cpp` の `perform_roattion()` が壁キック等を伴う回転処理を行なっているので，これが活用できないか確認してもらう．
これが素直に活用できない状態だとしたら，これが活用できるような修正案を考えて実施してほしい．

```
壁キックを伴う回転処理は `puyo_controller.cpp` の `perform_rotation()` が担っていると思います．
これを活用するようにしてほしいですが，素直に活用できない状態だとしたら，これが活用できるような修正案を考えて修正してほしいです．
```

これをやっている間に，`5-hour limit reached・resets 4pm` となってしまった．
リポジトリが大きくなってきたので，レート制限に引っかかりやすくなってしまっているのかもしれない．

レート制限に引っかかるようになった時点でのリポジトリサイズを確認しておく．

Claude Code が作成したファイルを格納する主なディレクトリ `cpp/`, `docs/`, `python/`, `tests/` について，`.md`, `.py`, `.cpp`, `.h` ファイルを対象として3つの指標を算出：
- ファイル数合計
- 行数合計
- 1ファイル当たりの平均行数

コマンド：
```
find cpp docs python tests -type f \( -name '*.cpp' -o -name '*.py' -o -name '*.h' -o -name '*.md' \) -print > /tmp/filelist.txt && xargs wc -l -m < /tmp/filelist.txt | awk 'FNR>1 { files++; lines+=$1; chars+=$2 } END { if (files>0) { print "ファイル数: " files "\n行数合計: " lines "\n文字数合計: " chars "\n平均行数: " int(lines/files) "\n平均文字数: " int(chars/files) } else { print "ファイルが見つかりません" } }'
```

結果：
```
ファイル数: 61
行数合計: 13463
文字数合計: 359461
平均行数: 220
平均文字数: 5892
```

このサイズ感のリポジトリで `claude -r` で履歴を継承した状態でタスクをいくつかやらせると，5h のレート制限に引っかかる状態らしい．

一旦 Claude Code が実行しようとしていたテスト `test_wall_kick.py` を手動で動かしてみたところ，クイックターンにさらに問題が発生していることが発覚した．
これを Claude Code に伝えたいが，どのように伝えればよいか．
チケット 007b は チケット 007 に紐づくバグフィックス用のチケットなので，ここではクイックターンのテストは行なわないことにして，代わりにチケット 002 のバグフィックスとして報告するようにすれば良さそう．

```
チケット 007b のタスクについて，`test_wall_kick.py` を手動で動かしてみたところ，クイックターンの挙動もおかしいことが判明しました．
しかしこれはチケット 007 の問題ではなくチケット 002 の問題なので，今回のチケット 007b のバグフィックスではクイックターンのテストは含めないようにしておいてください．
チケット 007b は最後まで実施してもらうとして，クイックターンの挙動がおかしい問題については別チケットとして切り出してほしいです．
具体的には，軸ぷよの両サイドに障害物がある場合，1回目の回転操作では回転が起こらず，2回目の回転操作で180度回転が発生することを想定していますが，それができていないです．
軸ぷよの両サイドに障害物がある状態で回転を行なおうとしたときに，次回回転はクイックターンになるというフラグが C++ 側で用意されている必要があると思います．
```

ということで，チケット 012 としてバグフィックスチケットを作成してくれたので，それに基づいてタスクを実行してもらう．
ただし，トークンを使いすぎないようにするために，Claude Code を開き直して履歴なしの状態から始めることにする．
また，チケット番号で指定するのではなく，`@` を使ってファイルを明示的に指定してあげることで負荷を減らす．

```
@docs/012-quick-turn-fix.md チケットを実施してください．
```

テスト作成段階で Claude Code がこれまでに使ってこなかった gtest を使って C++ のテストを記述しようとしてきた．
テストの実施方法は変えてほしくないので，gtest を使わないようにと追加指示を出す．

```
gtest はこれまでの C++ のテスト実装で用いてこなかったので， @tests/test_game_engine.cpp 等を参考に gtest を用いずにテストを実装してください．
```

単体テストの内容に若干の不備があったので，そこは手動で修正したが，それ以外は問題なさそうだった．

Claude Code の履歴を引き継がないようにしたことで，テスト結果の記録を行なってくれなくなったので，もう一度お願いをするとともに `claude.md` の更新をしてもらう（すでに `claude.md` に明記はしているが，うまく実施してくれなかった）．

```
テスト結果の記録がまだ行なわれていません． @claude.md にルールが記述してありますので，それに基づいてテスト結果の記録を行なってください．
次回以降，Claude Code がきちんとテスト結果の記録を行なうように， @claude.md に追記しておいてください．
```

これにてチケット 012 の対応も完了．
およそ 1h．

まだネクスト表示や連鎖システムが UI 上で表現できていないので，それを追加機能としてチケット化してもらう．

```
@docs/006-python-bindings.md, @docs/007-python-ui.md, @docs/007a-ui-bugfix.md, @docs/007b-ui-bugfix2.md をチケットタスクを経て，C++ で実装したぷよぷよを python で動かせるよう準備を進めてきました．
まだ python で動かした際に実現できていない機能がいくつかあるので，AI のフレームワーク開発に取り組む前に，それらを実現するためのチケットを作成してほしいです．

- 人間プレイヤー用の通常モードの機能を漏れなく実装しきる
  - ネクスト表示がまだできていないので，ネクスト表示が行なえるようにする
  - 4つのぷよが隣接しても連鎖が発生しない状態なので，連鎖が行なわれるようにし，連鎖数を画面に表示するようにする
  - 連鎖が発生しないことでスコアの計算も行なわれていない状態なので，スコア計算も行なわれるようにし，スコアを画面下部に表示するようにする

C++ で実装済みの機能をうまく使うようにしてほしいです．
```

チケット作成をしてもらったところ，既に作成されているチケット番号と重複してしまっていたので，それは修正してもらう．

```
既存のチケット番号と重複しないようにしてほしいです．
先ほど作成してもらった @docs/008-next-display.md も同様です．
```

チケット 013, 014, 015 として作成してもらったので，それをもとにタスクを実行してもらう．

```
チケット @docs/013-next-display.md を実施してください．
```

こちらが手を加えることなく最後までテストも実施できた．
わずか 5min.

次のタスクをお願いする．

```
チケット @docs/014-chain-system-integration.md を実施してください．
```

テストのやり方でつまづいていたので，直近のチケット 013 のやり方を参考にするよう伝えてみる．

```
@docs/test-results-013.md を見るとうまくテストが行なえていたようなので，この辺りを参考に今回のテストも実施してみてください．
もしうまくいったなら， 次回 Claude Code がタスクを実行する際に困らないよう @claude.md に追記してください．
```

リポジトリが大きくなるにつれて，`claude.md` に記載されているルールを破ることが増えてきた気がする．
チケットの完了したところにチェックを入れるようにするなど，明記してあることが行なわれないことがあるので，そういうものはまた別の機能（hook？）を使って行なってもらうようにした方が良いかもしれない．
`claude.md` 内にあるぷよぷよのゲームルールに関する記述を `puyo_game_information.md` に切り分けておいた．

10 min. 程度かかった．

次のタスクをお願いする．

```
チケット @docs/015-score-system-integration.md を実施してください．
```

単体テストで使われる数値を少し直す程度で済んだ．
が，やはり `claude.md` に記載していたルールを破りがちなのが気になるところ．
作業自体は 10 min. 程度で完了した．

ここまででほとんどぷよぷよエミュレータの作成が完了した．
細かい UI の修正などやりたいことはあるが，一旦動きとしては問題ないことが確認できたので，AI Platform の方へ遂に着手を始められることになる．


では，いよいよ AI Platform の方に着手する．

```
まずはこのプロジェクトを理解してください．
その後，チケット @008-ai-framework.md を実施してください．
@claude.md に記述していますが，テスト記録やテストの実行，チケットへの記録などを忘れないようにして，プログラムを動かす際にはビルド方法などを参照してください．
```

エミュレータ側がしっかりしてきたので，AI の基本的な枠組みを作るのは簡単に Claude Code 単体のパワーでやってくれた．
およそ 5min.


そういえば，人間がプレイすることはできるようになったが，AI が自律的にエミュレータを操作してプレイすることはまだ出来ない状態なので，このままだとチケット 009 のバトルシステム構築に影響が出る可能性がある．
そもそも，対戦ができるようにすることよりも AI のソロイがきちんとできるようになることの方が重要なので，チケットの再生成をしておこうと思う．
具体的には，チケット 009, 010, 011 は後回しにして，チケット 016 以降の番号で次のことをチケット化する．
- AI が自律的にエミュレータを操作してゲームをプレイできるようにする
  - AI はチケット 008 で作成した `RandomAI` を使えばよいが，今後 `AIBase` から作られた別の AI でも利用可能な状態になっている

```
チケットを1つ追加で作成してほしいです．
人間がとことんモードでぷよぷよエミュレータをプレイすることはできるようになっていますが， @docs/008-ai-framework.md で作成した AI が自律的にとことんモードでぷよぷよエミュレータをプレイするようにはなっていないです．
引き続き人間がプレイするモードはできるようにしていてほしいですが，`BaseAI` から作られた AI がエミュレータを操作して，ぷよぷよを自律的にプレイするようにもしたいです．

上記の記述をもとに，まずは Claude Code が作業可能な形でチケット化してください．
チケット作成に関する情報は @claude.md を参照してください．
チケットの書き方については，実際のチケット（例えば @docs/008-ai-framework.md）を参照してください．
```

```
では， #docs/016-ai-autonomous-play.md に取り組んでください．
ビルドとテストの実行方法やテストの記録方法などについて， @claude.md にルールを記載しているので，それに従ってください．
```

Claude Code 的にはテストもすべて実施できたとのことだったので，自分もコマンドを実行して確認してみたところ，まだエラーが残っている状態だった．

````
私も動作確認をしてみたのですが，AI Player を選択するとエラーが発生しました．
エラーを修正して AI Player によるゲームプレイが行なわれる状態にしてください．


```shell
python3 python/ui/game_controller.py 
```

```shell
/home/sion2000114/workspaces/wsl-claude-code-puyoai2/venv/lib/python3.12/site-packages/pygame/pkgdata.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
  from pkg_resources import resource_stream, resource_exists
pygame 2.6.1 (SDL 2.28.4, Python 3.12.3)
Hello from the pygame community. https://www.pygame.org/contribute.html
Puyo Puyo UI Demo Starting...
Select mode: [1] Human Player [2] AI Player
Enter choice (1 or 2): 2
AI Mode Selected
Game loop started. AI will play automatically. R to reset, ESC to quit.
Added player: AI Player (Type: PlayerType.AI)
New pair from NextGenerator: PuyoColor.YELLOW + PuyoColor.YELLOW
Game setup completed
AI decision: MoveCommand.RIGHT
AI reason: Random selection: RIGHT
Traceback (most recent call last):
  File "/home/sion2000114/workspaces/wsl-claude-code-puyoai2/python/ui/game_controller.py", line 371, in <module>
    main()
  File "/home/sion2000114/workspaces/wsl-claude-code-puyoai2/python/ui/game_controller.py", line 364, in main
    controller.render()
  File "/home/sion2000114/workspaces/wsl-claude-code-puyoai2/python/ui/game_controller.py", line 269, in render
    'ai_name': getattr(self.player_controller, 'ai', {}).get('name', 'Unknown AI'),
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'puyo_ai_platform.ai.RandomAI' object has no attribute 'get'
```

````

ここまでで，当初の「個人環境において，今回の取り組みでどのように利用する予定か」の **1.** でやろうとしていたことが完了したことになる．
これから **2.** の内容に着手するので，そのチケットを作成する．

...ということを考えていたが，実装をよく見てみると AI の思考処理 `think()` の戻り値である構造体 `AIDecision` に含まれる情報がぷよを設置する場所ではなく操作コマンドを表す列挙型 `MoveCommand` になっていることに気づいた．
AI の出力は軸ぷよの列 $x$ とその組ぷよの回転状態 $r$ の組 $(x, r)$ を含むものを想定していたので，少しリファクタしたい．

$x$ はフィールドの横幅，$r$ は4種類の回転状態を表すようにする必要があって，構造体 `AIDecision` では `MoveCommand` のリストと $(x, r)$ を表すものを持たせて，それを順に `player_controller.py` の `get_next_command()` で操作させるような形になれば良さそう．
$(x, r)$ に対してどのような操作を行なえば到達可能なのかを定義する必要もありそう．

- 基本的には $x < 2$ の場合は軸ぷよの列が $x$ になるまで左移動した後に回転状態 $r$ になるまで回転（右の場合は右回転1回，下の場合は右回転2回，左の場合は左回転1回）させて，$x > 2$ の場合は軸ぷよの列が $x$ になるまで右移動したあとに回転状態 $r$ になるまで回転（左の場合は左回転1回，下の場合は左回転2回，右の場合は右回転1回）させればよい
- ただし，移動途中の列 $l$ に12段目までぷよが設置されている場合は上の操作では $(x, r)$ まで到達できないので，
  - 到達可能な列（2列目からスタートして1つずつ左移動してどの列も12段未満な列の集合と，2列目からスタートして1つずつ右移動してどの列も12段未満な列の集合の和集合）の中で11段の列が存在する場合，2列目に最も近いその11段の列まで横移動して，「床キックによって軸ぷよの高さを1段上げてから $x$ の位置まで移動する」
    - 「」で囲まれた部分の詳細を記述する必要があるが，場合分けが結構複雑なので，どうしようかなあ...

複雑な操作が求められるので，一旦組ぷよの生成位置を1マス上へ上げることで操作を簡単に行なえるようにした方が良さそう？
でも組ぷよが1段上になると14段目のぷよと抵触するので扱いがそれはそれで難しくなる...

14段目のぷよへの壁キックを追加実装することでなんとかならないだろうか？

つまり，
- 基本的には $x < 2$ の場合は軸ぷよの列が $x$ になるまで左移動した後に回転状態 $r$ になるまで回転（右の場合は右回転1回，下の場合は右回転2回，左の場合は左回転1回）させて，$x > 2$ の場合は軸ぷよの列が $x$ になるまで右移動したあとに回転状態 $r$ になるまで回転（左の場合は左回転1回，下の場合は左回転2回，右の場合は右回転1回）させればよい
- ただし，移動途中の列 $l$ に12段目までぷよが設置されている場合は上の操作では $(x, r)$ まで到達できないので，
  - 到達可能な列（2列目からスタートして1つずつ左移動してどの列も12段未満な列の集合と，2列目からスタートして1つずつ右移動してどの列も12段未満な列の集合の和集合）の中で11段の列が存在する場合，2列目に最も近いその11段の列 $l^*$ まで横移動して，
    - $l^*$ まで左移動してきた場合，右回転を2回して，
      - $x < l^*$ の場合，左回転を1回する
      - $x > l^*$ の場合，右回転を1回する
    - $l^*$ まで右移動してきた場合，左回転を2回して，
      - $x < l^*$ の場合，左回転を1回する
      - $x > l^*$ の場合，右回転を1回する
  - 軸ぷよの列が $x$ になるまで移動して，回転状態 $r$ になるまでぷよを回転させる
    - $x < 2$ の場合，回転状態は右になっているはずなので，回転状態を上にするなら左回転，下にするなら右回転，左なら右回転2回，右なら回転しない
    - $x > 2$ の場合，回転状態は左になっているはずなので，回転状態を上にするなら右回転，下にするなら左回転，右なら左回転2回，右なら回転しない
- 最後に落下操作させる

これで行けるのではないか？

チケット化が必要なのは，
- チケット：ぷよぷよエミュレータの微修正
  - 上への回転で壁キックが入るようにする（主に `puyo_controller.cpp`）
    - 上（14段目）にぷよがある場合：x方向に-1
  - 組ぷよ設置可能判定の修正（`field.cpp`）
    - ぷよぷよの厳密な判定チェックアルゴリズムが存在するので，以下のサンプルコードをもとに `can_place_puyo_pair()` を修正する
```cpp
bool Field::can_place(int x, int r) const {
		// ぷよの高さ情報を取得
		uint8_t heights[6] = {};
		for (int i = 0; i < 6; ++i) {
			heights[i] = 0;
			for (int y = get_height() - 1; y > 0; --y) {
				if (static_cast<int>(get_cell(i, y)) != 0) heights[i] = get_height() - y;
			}
		}
		// 14段目の情報（bit列）
		uint8_t row14 = 0;
		for (int i = 0; i < 6; ++i) {
			if (heights[i] == 14) row14 |= (1 << i);
		}
		// 回転方向のオフセット
		static const int dx[4] = {0, 1, 0, -1}; // UP, RIGHT, DOWN, LEFT
		static const int dy[4] = {-1, 0, 1, 0};
		// 0:UP, 1:RIGHT, 2:DOWN, 3:LEFT
		int dir = r;
		// 軸ぷよが14段目
		if (heights[x] + (dir == 2) > 12) return false;
		int child_x = x + dx[dir];
		if (child_x < 0 || child_x >= 6) return false;
		int child_y = heights[child_x] + (dir == 0);
		if (child_y == 13 && ((row14 >> child_x) & 1)) return false;
		// チェックリスト
		static const int check[6][4] = {
			{1, 0, -1, -1}, {1, -1, -1, -1}, {-1, -1, -1, -1}, {3, -1, -1, -1}, {3, 4, -1, -1}, {3, 4, 5, -1}
		};
		static const int check_12[6][6] = {
			{1, 2, 3, 4, 5, -1}, {2, 3, 4, 5, -1, -1}, {-1, -1, -1, -1, -1, -1}, {2, 1, 0, -1, -1, -1}, {3, 2, 1, 0, -1, -1}, {4, 3, 2, 1, 0, -1}
		};
		int check_x = x;
		if (dir == 1 && x >= 2) check_x += 1;
		else if (dir == 3 && x <= 2) check_x -= 1;
		int height_12_idx = -1;
		for (int i = 0; check[check_x][i] != -1; ++i) {
			if (heights[check[check_x][i]] > 12) return false;
			if (heights[check[check_x][i]] == 12 && height_12_idx == -1) height_12_idx = check[check_x][i];
		}
		if (height_12_idx == -1) return true;
		if (heights[1] > 11 && heights[3] > 11) return true;
		for (int i = 0; check_12[height_12_idx][i] != -1; ++i) {
			if (heights[check_12[height_12_idx][i]] > 11) break;
			if (heights[check_12[height_12_idx][i]] == 11) return true;
		}
		return false;
	}
```

- チケット：AI の意思決定・エミュレータの操作に関する修正
  - AI の思考処理 `think()` の戻り値である構造体 `AIDecision` に含まれる情報がぷよを設置する場所ではなく操作コマンドを表す列挙型 `MoveCommand` になっていたので，AI の出力は軸ぷよの列 x とその組ぷよの回転状態 r の組 (x, r) を基準としたものにしたい
    - 具体的には，`AIDecision` には (x, r) の情報とそこへ到達するまでの `MoveCommand` のリストが入るようにしたい
    - `MoveCommand` のリスト作成は，以下のアルゴリズムに従う：
      - 基本的には $x < 2$ の場合は軸ぷよの列が $x$ になるまで左移動した後に回転状態 $r$ になるまで回転（右の場合は右回転1回，下の場合は右回転2回，左の場合は左回転1回）させて，$x > 2$ の場合は軸ぷよの列が $x$ になるまで右移動したあとに回転状態 $r$ になるまで回転（左の場合は左回転1回，下の場合は左回転2回，右の場合は右回転1回）させればよい
      - ただし，移動途中の列 $l$ に12段目までぷよが設置されている場合は上の操作では $(x, r)$ まで到達できないので，
        - 到達可能な列（2列目からスタートして1つずつ左移動してどの列も12段未満な列の集合と，2列目からスタートして1つずつ右移動してどの列も12段未満な列の集合の和集合）の中で11段の列が存在する場合，2列目に最も近いその11段の列 $l^*$ まで横移動して，
          - $l^*$ まで左移動してきた場合，右回転を2回して，
            - $x < l^*$ の場合，左回転を1回する
            - $x > l^*$ の場合，右回転を1回する
          - $l^*$ まで右移動してきた場合，左回転を2回して，
            - $x < l^*$ の場合，左回転を1回する
            - $x > l^*$ の場合，右回転を1回する
        - 軸ぷよの列が $x$ になるまで移動して，回転状態 $r$ になるまでぷよを回転させる
          - $x < 2$ の場合，回転状態は右になっているはずなので，回転状態を上にするなら左回転，下にするなら右回転，左なら右回転2回，右なら回転しない
          - $x > 2$ の場合，回転状態は左になっているはずなので，回転状態を上にするなら右回転，下にするなら左回転，右なら左回転2回，右なら回転しない
      - 最後に落下操作させる
  - 過去に作った `RandomAI` を修正して，ランダムな操作ではなく配置可能なランダムな場所に組ぷよを配置する AI になるようにする

この記述をもとに，Claude Code にチケットを2つ生成してもらう．

```
チケットを2種類追加で作成してほしいです．
チケットの作成ルールは `claude.md` に記載の通りです．

（上の記述をここにコピペ）
```

最初のチケットを実施してもらっているところ，設置可能判定のところでつまづいていた．
チケットにはサンプルコードを用意しているので，そのサンプルと同等の仕様を再現してもらう必要があるのに，簡単な実装で解決しようとしていたので，それを阻止する．

````
基本的な実装に戻さないでください．
この `can_place()` の実装で求められているのは，チケットに記載したサンプルコードと同等の処理を今回の pj でも再現することです．
今の表現だとサンプルコードにある「チェックリスト」の判定がなくなってしまっているので，もう一度チケットに記載したサンプルコードの実装を確認して，漏れがないように修正をお願いします．
````

```
意図しない挙動をする原因が分かりました．
@docs/017-emulator-fixes.md で `can_place_puyo_pair()` を `can_place()` に置き換えるという指示を出していることそのものに問題がありそうでした．
`can_place_puyo_pair(pair)` は `pair` が指定する座標に組ぷよを配置可能かどうかを判断する関数で，`can_place(x, r)` は操作中の組ぷよがその位置と向きで設置しようとしたときに到達可能か堂かも含めて判断する関数として扱いたいです．
したがって，`can_place_puyo_pair()` は従来の実装に戻して，`can_place()` は今後の AI が設置可能な組ぷよの組み合わせを取得する際に利用できるように残しておいてください．
これを踏まえて，`can_place_puyo_pair()` の実装を修正したので，再度テストをお願いします．
```

自分がチケットでの指示出しを間違えていたことで中々想定した挙動にならなくなってしまっていた．
簡単なリファクタだがこの事実に気づくまでに 4h ほどかかってしまった．

追加チケット2つ目を実施してもらう．

```
まずは @claude.md を読んでこの pj を理解してください．
ビルドとテストの実行方法，テストの記録方法などに注意してください．

それが完了したら，チケット @docs/018-ai-decision-improvements.md を実施してください．
```

C++ のコマンド生成のテストで不具合あり
```
問題の test_field_with_12_height では，1列目・回転状態上としてぷよを設置しようとしたときに，3列目からの移動途中である2列目に12段まで積まれているので通常の操作は行なえず，到達可能な5列目に11段の高さまでぷよが積まれているので，そこを経由して操作される想定です．
そのため，generate_move_commands() を呼び出して，内部的には generate_advanced_commands() が呼び出されるはずですが，基本操作しか行なわれていないような結果に見えるので，generate_advanced_commands() を少し修正してエラーが発生する可能性があるようにしました．
再度テストをお願いします．
```

```
高さ計算のロジックに問題があったので修正しました．
再度テストしてもらった結果，generate_rotation_commands() に問題があることが分かりました．

1. RIGHT RIGHT - 2列目から4列目（5列目、インデックス4）への移動
2. ROTATE_CCW ROTATE_CCW ROTATE_CCW - UP→LEFT方向への3回回転
3. LEFT LEFT LEFT LEFT - 4列目から0列目への移動
4. ROTATE_CCW ROTATE_CCW - LEFT→UP方向への2回回転
5. DROP - 最終落下

この 4. の部分は，LEFT から UP なので ROTATE_CW 1回が正しいのですが，実際は ROTATE_CCW 2回になっています．
```

この指示＋手動での微修正によって，タスクが完了した．
その後，`game_controller.py` を動かしてみたが，こちらへの修正がまだ行なわれていなかったので，`RandomAI` が動かなかった．
こちらの修正まで対応をお願いする．

```
今回の @docs/018-ai-decision-improvements.md の対応によって `RandomAI` の挙動の修正を行なってもらいましたが，この変更によって @python/ui/game_controller.py の AI Mode が動かなくなってしまいました．
こちらへの対応も @docs/018-ai-decision-improvements.md に含めて対応してほしいです．
そのために，以下の作業を行なってください．
- @docs/018-ai-decision-improvements.md への追加作業の追記
- @python/ui/game_controller.py の AI Mode が今回の変更に対応するように修正して，AI Mode が動く状態まで持っていく
- @docs/018-ai-decision-improvements.md にチェックを入れる（@claude.md 参照）
```

## 高度な AI model を作成させてみる

この内容を AI PoC で報告するレポート作成のための2つ目の検証「探索アルゴリズムや強化学習モデルの構築など，高度な実装を行なわせてみる」とする．

ぷよぷよをプレイする非常に簡単なモデルとして `RandomAI` を用意している状態で，`AIBase` クラスを継承することによって別の AI モデルを開発しやすくなっているはず．

ただ，`ai_base.h` も完璧な設計になっているわけではなく，例えば `GameState` クラスにまだネクストの情報 `next_queue` が存在していなかったりするので，そのあたりは柔軟に機能拡張してほしい．

```
`AIBase` クラスを継承して過去に作った `RandomAI` を参考に，別の新しいぷよぷよ AI を開発してほしいです．
ざっくり次のような AI が作られることを想定しています．

- 前提
  - AI への入力は操作中のぷよ・ネクスト・ネクネク・フィールドとする
- モデル案
  - 連鎖探索型 AI
    - 将来的に連鎖数が大きくなりかつ連鎖の発火が可能な最適な次の一手を探索できる
  - 強化学習型 AI
    - 将来的に連鎖数が大きくなりかつ連鎖の発火が可能な最もスコアの高い一手を選択できる
  - 人のプレイを学習する AI
    - 例えば，自分（人間）がぷよぷよをプレイするところを学習して，自分の組み方に似たプレイができるようになる

これらの AI を @ui/game_controller.py で動作させられるようにしてほしいです．

まずはこれらの内容でチケット化してください．
チケットの作り方は @claude.md や実際のチケットを参考にしてください．
```

ここからはもう Claude Code の赴くままに実装をさせてみようと思う．

```
では，チケット @docs/019-advanced_ai_systems.md を実施してください．
動作確認は AI model ごとに行なってください．
一気にモデル構築をしてから動作確認をしようとすると複雑になってしまう可能性があるので注意してください．
```

1つ目の連鎖探索型 AI が出来上がるまでものの 5min. 程度で動作するところまで来ていた．
その後も流れのまま3つ分のモデルが構築され，動作するところまで来たが，本当に連鎖探索や強化学習の実装ができているのか？
ましてや，人のプレイを学習する AI については，特にこちらからプレイデータを提供していないのに，なぜ動く状態なのか？

中身を見る時間がないので，大胆に Claude Code に聞いてみる．

```
@docs/019-advanced_ai_systems.md で作成してもらった3つのモデル
- 連鎖探索型 AI
- 強化学習型 AI
- 人のプレイを学習する AI
を実際に私の方でも動かして動作を見てみましたが，どの AI も連鎖が構築できるようなレベルまで至っておらず，ランダム AI の方がまだマシなレベルでした．
モデルの改善を行なってほしいです．
とりあえず私が気づいたことを以下にメモします：
- モデル全体
  - ネクスト・ネクネクの情報も AI の意思決定に活用する（`AIBase` クラスの改良が必要か？）
- 各モデル
  - 連鎖探索型 AI
    - 評価関数
      - 連鎖構築中の地形は U 字に近い方が良型のパターンが多い（経験則）
      - 用いるハイパーパラメータの値を yaml 等で管理して，より大連鎖が安定して組めるようなハイパーパラメータを探索してモデル改善を行なう
   - 強化学習型 AI
    - 事前に学習させたデータが使えていないのでは？
  - 人のプレイを学習する AI
    - これも強化学習型 AI と同様に，事前に学習させたデータが使えていないのでは？

これらのことをはじめとしたモデル改善を実施して，実際により多くの連鎖が組めるようになった AI モデルを @python/ui/game_controller.py から動かせるようにしてほしいです．
そのために，まずはチケットを作成して欲しいです．
チケットの作成方法は @claude.md や `docs/` 配下にある実際のチケットを参考にしてください．
```

結構重たそうなチケットが作成されたが，ひとまず Claude Code にすべてお任せしてみる．
1:55 作業開始
2:05 作業完了
とりあえず 10min. で終わったが，果たして結果やいかに．

まあ正直，期待したものはできていない．
そもそも連鎖判定や組ぷよの配置などは C++ 側で実装していたのに，強化学習型 AI の実装内で Python で実装しなおしていたりするので，C++ のものを使ってほしい．
さらに，学習後のモデルで実際に動かせるところまでできていなさそうだったので，ちゃんと改善されたモデルで動作を確認できる状態になっていることが望ましい．

```
いくつか問題点があるので，それを修正してほしいです．

- C++ 側の実装が活用できていない
  - 例えば， @python/ai/rl_training_demo.py の `_can_place()` などは，C++ 側に既に実装されている
  - 基本的に，ぷよエミュレータ上の操作はすべて C++ 側の実装を利用してほしい（処理を高速に行なうためにわざわざ C++ で実装したので，活用する必要がある）
  - AI モデルの学習の際に C++ で実装したエミュレータを利用すれば本番相当のデータを使って学習できるので，そちらを使うべき
- 学習後のモデルで実際に動作を見ることができない
  - 最終的に @python/ui/game_controller.py を起動して作成した AI モデルを動かしてみたいので，モデルの学習結果をきちんと反映させてほしい

これらのことを踏まえて，AI モデルの修正，学習システムの修正，「実際に学習したモデル」を @python/ui/game_controller.py で動作確認できるように修正してください．
```

この後も上記のような依頼を何度かしたが，せっかく作った C++ の機能をうまく使えず，学習した結果を実際のモデルの挙動に使えていなかったり，ランダム AI の方が長く生存できるほどモデル性能も低いものだった．
やはりこのあたりの高度なタスク要望は厳しいのかもしれない．

今回はこの辺りにしてレポート作業に入ろうと思う．

## 報告書フォーマット

ここまで実験してきたことをレポートとしてまとめる必要がある．
フォーマットが事前に決まっているので，`Report.md` として書き出しておく．

